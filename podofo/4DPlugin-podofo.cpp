/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-podofo.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : podofo
 #	author : miyako
 #	2020/10/23
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-podofo.h"

#pragma mark -

static void OnStartup() {
    
#ifdef PODOFO_HAVE_OPENSSL_1_1
    OPENSSL_init_crypto(0, NULL);
#else
    OpenSSL_add_all_algorithms();
    ERR_load_crypto_strings();
    ERR_load_PEM_strings();
    ERR_load_ASN1_strings();
    ERR_load_EVP_strings();
#endif
}

static void OnExit() {
    
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- podofo
                
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                OnExit();
                break;
                
            case 1 :
                podofosign(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

static int print_errors_string(const char *str, size_t len, void *u) {
    
    std::string *pstr = reinterpret_cast<std::string *>( u );
    
    if( !pstr || !len || !str )
        return 0;
    
    if( !pstr->empty() && (*pstr)[pstr->length() - 1] != '\n' )
        *pstr += "\n";
    
    *pstr += std::string( str, len );
    
    // to continue
    return 1;
}

static int pkey_password_cb(char *buf, int bufsize, int PODOFO_UNUSED_PARAM(rwflag), void *userdata) {
    
    const char *password = reinterpret_cast<const char *>(userdata);
    
    if (!password)
        return 0;
    
    int res = (int)strlen( password );
    
    if (res > bufsize)
        res = bufsize;
    
    memcpy( buf, password, res );
    
    return res;
}

static FILE *ufopen(const char *filename, const char *mode) {
    
#ifdef _WIN32
    wchar_t    buf[_MAX_PATH];
    wchar_t    _wfmode[99];    //should be enough
    if(MultiByteToWideChar(CP_UTF8, 0, mode, -1, (LPWSTR)_wfmode, 99))
    {
        if(MultiByteToWideChar(CP_UTF8, 0, filename, -1, (LPWSTR)buf, _MAX_PATH))
        {
            return _wfopen((const wchar_t *)buf, (const wchar_t *)_wfmode);
        }
    }
    return  fopen(filename, mode);
#else
    return fopen(filename, mode);
#endif
}

static PdfObject* find_existing_signature_field(PdfAcroForm* pAcroForm, const PdfString& name) {
    
    if( !pAcroForm )
        PODOFO_RAISE_ERROR( ePdfError_InvalidHandle );
    
    PdfObject* pFields = pAcroForm->GetObject()->GetDictionary().GetKey( PdfName( "Fields" ) );
    if( pFields )
    {
        if( pFields->GetDataType() == ePdfDataType_Reference )
            pFields = pAcroForm->GetDocument()->GetObjects()->GetObject( pFields->GetReference() );
        
        if( pFields && pFields->GetDataType() == ePdfDataType_Array )
        {
            PdfArray &rArray = pFields->GetArray();
            PdfArray::iterator it, end = rArray.end();
            for( it = rArray.begin(); it != end; it++ )
            {
                // require references in the Fields array
                if( it->GetDataType() == ePdfDataType_Reference )
                {
                    PdfObject *item = pAcroForm->GetDocument()->GetObjects()->GetObject( it->GetReference() );
                    
                    if( item && item->GetDictionary().HasKey( PdfName( "T" ) ) &&
                       item->GetDictionary().GetKey( PdfName( "T" ) )->GetString() == name )
                    {
                        // found a field with the same name
                        const PdfObject *pFT = item->GetDictionary().GetKey( PdfName( "FT" ) );
                        if( !pFT && item->GetDictionary().HasKey( PdfName( "Parent" ) ) )
                        {
                            const PdfObject *pTemp = item->GetIndirectKey( PdfName( "Parent" ) );
                            if( !pTemp )
                            {
                                PODOFO_RAISE_ERROR( ePdfError_InvalidDataType );
                            }
                            
                            pFT = pTemp->GetDictionary().GetKey( PdfName( "FT" ) );
                        }
                        
                        if( !pFT )
                        {
                            PODOFO_RAISE_ERROR( ePdfError_NoObject );
                        }
                        
                        const PdfName fieldType = pFT->GetName();
                        if( fieldType != PdfName( "Sig" ) )
                        {
                            std::string err = "Existing field '";
                            err += name.GetString();
                            err += "' isn't of a signature type, but '";
                            err += fieldType.GetName().c_str();
                            err += "' instead";
                            
                            PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidName, err.c_str() );
                        }
                        
                        return item;
                    }
                }
            }
        }
    }
    
    return NULL;
}

static double convert_to_pdf_units(const char *annot_units, double value) {
    
    if( strcmp( annot_units, "mm" ) == 0 )
    {
        return 72.0 * value / 25.4;
    }
    else if(  strcmp( annot_units, "inch" ) == 0 )
    {
        return 72.0 * value;
    }
    else
    {
        std::string err = "Unknown annotation unit '";
        err += annot_units;
        err += "'";
        
        PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidEnumValue, err.c_str() );
    }
}

static void raise_podofo_error_with_opensslerror(const char *detail) {
    
    std::string err;
    
    ERR_print_errors_cb( print_errors_string, &err );
    
    if( err.empty() )
        err = "Unknown OpenSSL error";
    
    err = ": " + err;
    err = detail + err;
    
    PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, err.c_str() );
}

static void sign_with_signer(PdfSignOutputDevice &signer, X509 *cert, EVP_PKEY *pkey) {
    
    if( !cert )
        PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, "cert == NULL" );
    if( !pkey )
        PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, "pkey == NULL" );
    
    unsigned int uBufferLen = 65535;
    size_t len;
    char *pBuffer;
    
    while( static_cast<void>(pBuffer = reinterpret_cast<char *>( podofo_malloc( sizeof( char ) * uBufferLen) )), !pBuffer )
    {
        uBufferLen = uBufferLen / 2;
        if( !uBufferLen )
            break;
    }
    
    if( !pBuffer )
        PODOFO_RAISE_ERROR (ePdfError_OutOfMemory);
    
    int rc;
    BIO *mem = BIO_new( BIO_s_mem() );
    if( !mem )
    {
        podofo_free( pBuffer );
        raise_podofo_error_with_opensslerror( "Failed to create input BIO" );
    }
    
    unsigned int flags = PKCS7_DETACHED | PKCS7_BINARY;
    PKCS7 *pkcs7 = PKCS7_sign( cert, pkey, NULL, mem, flags );
    if( !pkcs7 )
    {
        BIO_free( mem );
        podofo_free( pBuffer );
        raise_podofo_error_with_opensslerror( "PKCS7_sign failed" );
    }
    
    while( static_cast<void>(len = signer.ReadForSignature( pBuffer, uBufferLen )), len > 0 )
    {
        rc = BIO_write( mem, pBuffer, (int)len);
        if( static_cast<unsigned int>( rc ) != len )
        {
            PKCS7_free( pkcs7 );
            BIO_free( mem );
            podofo_free( pBuffer );
            raise_podofo_error_with_opensslerror( "BIO_write failed" );
        }
    }
    
    podofo_free( pBuffer );
    
    if( PKCS7_final( pkcs7, mem, flags ) <= 0 )
    {
        PKCS7_free( pkcs7 );
        BIO_free( mem );
        raise_podofo_error_with_opensslerror( "PKCS7_final failed" );
    }
    
    bool success = false;
    BIO *out = BIO_new( BIO_s_mem() );
    if( !out )
    {
        PKCS7_free( pkcs7 );
        BIO_free( mem );
        raise_podofo_error_with_opensslerror( "Failed to create output BIO" );
    }
    
    char *outBuff = NULL;
    long outLen;
    
    i2d_PKCS7_bio( out, pkcs7 );
    
    outLen = BIO_get_mem_data( out, &outBuff );
    
    if( outLen > 0 && outBuff )
    {
        if( static_cast<size_t>( outLen ) > signer.GetSignatureSize() )
        {
            PKCS7_free( pkcs7 );
            BIO_free( out );
            BIO_free( mem );
            
            std::ostringstream oss;
            oss << "Requires at least " << outLen << " bytes for the signature, but reserved is only " << signer.GetSignatureSize() << " bytes";
            PODOFO_RAISE_ERROR_INFO( ePdfError_ValueOutOfRange, oss.str().c_str() );
        }
        
        PdfData signature( outBuff, outLen );
        signer.SetSignature( signature );
        success = true;
    }
    
    PKCS7_free( pkcs7 );
    BIO_free( out );
    BIO_free( mem );
    
    if( !success )
        raise_podofo_error_with_opensslerror( "Failed to get data from the output BIO" );
}

#pragma mark -

static void convert_to_platform_path(CUTF8String& path) {
    
#if VERSIONMAC
    
    if(path.length()) {
        
        NSString *s = [[NSString alloc]initWithUTF8String:(const char *)path.c_str()];
        NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)s, kCFURLHFSPathStyle, false);
        if(u) {
            NSString *p = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
            [u release];
            path = CUTF8String((const uint8_t *)[p UTF8String]);
        }
        [s release];
    }
#endif
}

void podofosign(PA_PluginParameters params) {
    
    PA_ObjectRef returnValue = PA_CreateObject();
    
    CUTF8String u8_inputfile;
    CUTF8String u8_outputfile;
    
    CUTF8String u8_cert;
    CUTF8String u8_pkey;
    
    bool cert_is_file = false;
    bool pkey_is_file = false;
    
    CUTF8String u8_password;
    CUTF8String u8_reason;
    CUTF8String u8_field;
    bool field_use_existing = false;//negate "replace"
    int annot_page = 0;
    
    double annot_left = 0.0, annot_top = 0.0, annot_width = 0.0, annot_height = 0.0;
    
    bool annot_print = false;//automatic
    
    //    double annot_font_size = 5.0;
    //    const char *annot_units = NULL;
    //    const char *annot_font_name = NULL;
    //    PdfColor annot_font_color( 0.0, 0.0, 0.0 );
    //    const char *annot_image = NULL;
    
    bool bUpdateFont = true;//fixed
    
    PA_ObjectRef param = PA_GetObjectParameter(params, 1);
    PA_ObjectRef annotation = NULL;
    PA_CollectionRef images = NULL;
    PA_CollectionRef labels = NULL;
    
    //global params
    
    if(param) {
        
        if(ob_is_defined(param, L"replace")) {
            field_use_existing = ob_get_b(param, L"replace");
        }
        
        if(ob_is_defined(param, L"in")) {
            if(ob_get_s(param, L"in", &u8_inputfile)) {
                convert_to_platform_path(u8_inputfile);
            }
        }
        
        if(ob_is_defined(param, L"out")) {
            if(ob_get_s(param, L"out", &u8_outputfile)) {
                convert_to_platform_path(u8_outputfile);
            }
        }
        
        if(ob_is_defined(param, L"cert")) {
            ob_get_s(param, L"cert", &u8_cert);
        }
        
        if(ob_is_defined(param, L"certFile")) {
            if(ob_get_s(param, L"certFile", &u8_cert)) {
                convert_to_platform_path(u8_cert);
                cert_is_file = true;
            }
        }
        
        if(ob_is_defined(param, L"key")) {
            ob_get_s(param, L"key", &u8_pkey);
        }
        
        if(ob_is_defined(param, L"keyFile")) {
            if(ob_get_s(param, L"keyFile", &u8_pkey)) {
                convert_to_platform_path(u8_pkey);
                pkey_is_file = true;
            }
        }
        
        if(ob_is_defined(param, L"password")) {
            if(ob_get_s(param, L"password", &u8_password)) {
                
            }
        }
        
        if(ob_is_defined(param, L"reason")) {
            if(ob_get_s(param, L"reason", &u8_reason)) {
                
            }
        }
        
        if(ob_is_defined(param, L"field")) {
            if(ob_get_s(param, L"field", &u8_field)) {
                
            }
        }
        
        if(ob_is_defined(param, L"page")) {
            int _annot_page = ob_get_n(param, L"page");
            if( _annot_page > 0) {
                annot_page = _annot_page;
            }
        }
        
    }
    
    if(annot_page) {
        
        //because param.page is 1 based
        annot_page--;
        
        if(param) {
            
            if(ob_is_defined(param, L"annotation")) {
                annotation = ob_get_o(param, L"annotation");
                if(annotation) {
                    
                    const char *annot_units = NULL;
                    CUTF8String u8_unit;
                    if(ob_is_defined(annotation, L"unit")) {
                        if(ob_get_s(annotation, L"unit", &u8_unit)) {
                            if(u8_unit == (const uint8_t *)"inch"){
                                annot_units = "inch";
                            }
                        }
                    }
                    
                    if(!annot_units)
                        annot_units = "mm";
                    
                    annot_left = ob_get_n(annotation, L"x");
                    annot_top = ob_get_n(annotation, L"y");
                    annot_width = convert_to_pdf_units(annot_units, ob_get_n(annotation, L"width"));
                    annot_height = convert_to_pdf_units(annot_units, ob_get_n(annotation, L"height"));
                    
                    images = ob_get_c(annotation, L"images");
                    
                    if(images) {
                        if(PA_GetCollectionLength(images)) {
                            annot_print = true;
                        }
                    }
                    
                    labels = ob_get_c(annotation, L"labels");
                    
                    if(labels) {
                        if(PA_GetCollectionLength(labels)) {
                            annot_print = true;
                        }
                    }
                }
            }
        }
    }
    
    const char *inputfile = (const char *)u8_inputfile.c_str();
    const char *outputfile = (const char *)u8_outputfile.c_str();
    
    const char *password = u8_password.length() ? (const char *)u8_password.c_str() : NULL;
    const char *field_name = u8_field.length() ? (const char *)u8_field.c_str() : NULL;
    const char *reason = (const char *)u8_reason.c_str();
    
    const char *sigsizestr = NULL; //not used
    
    PdfError::EnableDebug(false);
    
    int sigsize = -1;
    
    if(sigsizestr) {
        sigsize = atoi(sigsizestr);
    }
    
    if(outputfile && strcmp(outputfile, inputfile)) {
        
        if(sigsize <= 0) {
            
            pdf_int32 min_signature_size = 0;
            
            X509* cert = NULL;
            EVP_PKEY* pkey = NULL;
            
            BIO *bio_cert = NULL;
            BIO *bio_pkey = NULL;
            
            if(u8_cert.length()) {
                
                FILE *fp = NULL;
                
                if(!cert_is_file) {
                    
                    bio_cert = BIO_new_mem_buf((const void *)u8_cert.c_str(), (int)u8_cert.length());
                    cert = PEM_read_bio_X509(bio_cert, NULL, NULL, NULL);
                    
                    min_signature_size += u8_cert.length();
                    
                }else{
                    
                    fp = ufopen((const char *)u8_cert.c_str(), "rb");
                    
                    if(fp) {
                        
                        cert = PEM_read_X509(fp, NULL, NULL, NULL);
                        
                        if(fseeko(fp, 0, SEEK_END ) != -1)
                            min_signature_size += ftello(fp);
                        else
                            min_signature_size += 3072;
                        
                        fclose(fp);
                        
                    }else{
                        //Failed to open certificate file
                    }
                }
                
            }else{
                //Certificate file not specified
            }
            
            if(u8_pkey.length()) {
                
                FILE *fp = NULL;
                
                if(!pkey_is_file) {
                    
                    bio_pkey = BIO_new_mem_buf((const void *)u8_pkey.c_str(), (int)u8_pkey.length());
                    pkey = PEM_read_bio_PrivateKey(bio_pkey,
                                                   NULL,
                                                   pkey_password_cb,
                                                   const_cast<char *>(password));
                    
                    min_signature_size += u8_pkey.length();
                    
                }else{
                    
                    fp = ufopen((const char *)u8_pkey.c_str(), "rb");
                    
                    if(fp) {
                        pkey = PEM_read_PrivateKey(fp,
                                                   NULL,
                                                   pkey_password_cb,
                                                   const_cast<char *>(password));
                        
                        if(fseeko(fp, 0, SEEK_END) != -1)
                            min_signature_size += ftello(fp);
                        else
                            min_signature_size += 1024;
                        
                        fclose(fp);
                    }else{
                        //Failed to private key file
                    }
                    
                }
                
            }else{
                //Private key file not specified
            }
            
            if((pkey) && (cert)) {
                
                if(sigsize > 0)
                    min_signature_size = sigsize;
                
                int result = 0;
                PdfSignatureField *pSignField = NULL;
                PdfAnnotation *pTemporaryAnnot = NULL; // for existing signature fields
                
                try
                {
                    PdfMemDocument document;
                    
                    document.Load( inputfile, true );
                    
                    if(document.GetPageCount()) {
                        
                        PdfAcroForm* pAcroForm = document.GetAcroForm();
                        if( !pAcroForm )
                            PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, "acroForm == NULL" );
                        
                        if( !pAcroForm->GetObject()->GetDictionary().HasKey( PdfName( "SigFlags" ) ) ||
                           !pAcroForm->GetObject()->GetDictionary().GetKey( PdfName( "SigFlags" ) )->IsNumber() ||
                           pAcroForm->GetObject()->GetDictionary().GetKeyAsLong( PdfName( "SigFlags" ) ) != 3 )
                        {
                            if( pAcroForm->GetObject()->GetDictionary().HasKey( PdfName( "SigFlags" ) ) )
                                pAcroForm->GetObject()->GetDictionary().RemoveKey( PdfName( "SigFlags" ) );
                            
                            pdf_int64 val = 3;
                            pAcroForm->GetObject()->GetDictionary().AddKey( PdfName( "SigFlags" ), PdfObject( val ) );
                        }
                        
                        if( pAcroForm->GetNeedAppearances() )
                        {
#if 0 /* TODO */
                            update_default_appearance_streams( pAcroForm );
#endif
                            
                            pAcroForm->SetNeedAppearances( false );
                        }
                        
                        PdfOutputDevice outputDevice( outputfile ? outputfile : inputfile, outputfile != NULL );
                        PdfSignOutputDevice signer( &outputDevice );
                        
                        PdfString name;
                        PdfObject* pExistingSigField = NULL;
                        
                        if( field_name )
                        {
                            name = PdfString( field_name );
                            
                            pExistingSigField = find_existing_signature_field( pAcroForm, name );
                            if( pExistingSigField && !field_use_existing)
                            {
                                std::string err = "Signature field named '";
                                err += name.GetString();
                                err += "' already exists";
                                
                                PODOFO_RAISE_ERROR_INFO( ePdfError_WrongDestinationType, err.c_str() );
                            }
                        }
                        else
                        {
                            char fldName[96]; // use bigger buffer to make sure sprintf does not overflow
                            sprintf( fldName, "PodofoSignatureField%" PDF_FORMAT_INT64, static_cast<pdf_int64>( document.GetObjects().GetObjectCount() ) );
                            
                            name = PdfString( fldName );
                        }
                        
                        if( pExistingSigField )
                        {
                            if( !pExistingSigField->GetDictionary().HasKey( "P" ) )
                            {
                                std::string err = "Signature field named '";
                                err += name.GetString();
                                err += "' doesn't have a page reference";
                                
                                PODOFO_RAISE_ERROR_INFO( ePdfError_PageNotFound, err.c_str() );
                            }
                            
                            PdfPage* pPage;
                            
                            pPage = document.GetPagesTree()->GetPage( pExistingSigField->GetDictionary().GetKey( "P" )->GetReference() );
                            if( !pPage )
                                PODOFO_RAISE_ERROR( ePdfError_PageNotFound );
                            
                            pTemporaryAnnot = new PdfAnnotation( pExistingSigField, pPage );
                            if( !pTemporaryAnnot )
                                PODOFO_RAISE_ERROR_INFO( ePdfError_OutOfMemory, "Cannot allocate annotation object for existing signature field" );
                            
                            pSignField = new PdfSignatureField( pTemporaryAnnot );
                            if( !pSignField )
                                PODOFO_RAISE_ERROR_INFO( ePdfError_OutOfMemory, "Cannot allocate existing signature field object" );
                            
                            pSignField->EnsureSignatureObject();
                        }
                        else
                        {
                            PdfPage* pPage = document.GetPage( annot_page );
                            if( !pPage )
                                PODOFO_RAISE_ERROR( ePdfError_PageNotFound );
                            
                            PdfRect annot_rect;
                            if(annot_print)
                            {
                                annot_rect = PdfRect( annot_left, pPage->GetPageSize().GetHeight() - annot_top - annot_height, annot_width, annot_height );
                            }
                            
                            PdfAnnotation* pAnnot = pPage->CreateAnnotation( ePdfAnnotation_Widget, annot_rect );
                            if( !pAnnot )
                                PODOFO_RAISE_ERROR_INFO( ePdfError_OutOfMemory, "Cannot allocate annotation object" );
                            
                            if(annot_print)
                                pAnnot->SetFlags( ePdfAnnotationFlags_Print );
                            else if( !annot_print && ( !field_name || !field_use_existing ) )
                                pAnnot->SetFlags( ePdfAnnotationFlags_Invisible | ePdfAnnotationFlags_Hidden );
                            
                            pSignField = new PdfSignatureField( pAnnot, pAcroForm, &document );
                            if( !pSignField )
                                PODOFO_RAISE_ERROR_INFO( ePdfError_OutOfMemory, "Cannot allocate signature field object" );
                            
                            if(annot_print)
                            {
                                PdfRect annotSize( 0.0, 0.0, annot_rect.GetWidth(), annot_rect.GetHeight() );
                                PdfXObject sigXObject( annotSize, &document );
                                PdfPainter painter;
                                
                                try
                                {
                                    painter.SetPage( &sigXObject );
                                    
                                    /* Workaround Adobe's reader error 'Expected a dict object.' when the stream
                                     contains only one object which does Save()/Restore() on its own, like
                                     the image XObject. */
                                    painter.Save();
                                    painter.Restore();
                                    
                                    /*
                                     labels
                                     */
                                    
                                    for(PA_long32 i = 0; i < PA_GetCollectionLength(labels);++i){
                                        
                                        PA_Variable v = PA_GetCollectionElement(labels, i);
                                        if(PA_GetVariableKind(v) == eVK_Object){
                                            PA_ObjectRef label = PA_GetObjectVariable(v);
                                            if(label) {
                                                const char *label_units = NULL;
                                                CUTF8String u8_unit;
                                                if(ob_is_defined(label, L"unit")) {
                                                    if(ob_get_s(label, L"unit", &u8_unit)) {
                                                        if(u8_unit == (const uint8_t *)"inch"){
                                                            label_units = "inch";
                                                        }
                                                    }
                                                }
                                                
                                                if(!label_units)
                                                    label_units = "mm";
                                                
                                                double label_left = ob_get_n(label, L"x");
                                                double label_top = ob_get_n(label, L"y");
                                                double label_width = convert_to_pdf_units(label_units,
                                                                                          ob_get_n(label, L"width"));
                                                double label_height = convert_to_pdf_units(label_units,
                                                                                           ob_get_n(label, L"height"));
                                                
                                                double label_font_size = 5.0;
                                                
                                                if(ob_is_defined(label, L"unit")) {
                                                    label_font_size = convert_to_pdf_units(label_units,
                                                                                           ob_get_n(label, L"font_size"));
                                                }
                                                
                                                const char *label_font = NULL;
                                                CUTF8String u8_font;
                                                if(ob_is_defined(label, L"font")) {
                                                    if(ob_get_s(label, L"font", &u8_font)) {
                                                        label_font = (const char *)u8_font.c_str();
                                                    }
                                                }
                                                
                                                if(!label_font)
                                                    label_font = "Helvetica";
                                                
                                                const char *label_text = NULL;
                                                CUTF8String u8_text;
                                                if(ob_is_defined(label, L"text")) {
                                                    if(ob_get_s(label, L"text", &u8_text)) {
                                                        label_text = (const char *)u8_text.c_str();
                                                    }
                                                }
                                                
                                                if(label_text) {
                                                    
                                                    double font_color_r = 0.0;
                                                    double font_color_g = 0.0;
                                                    double font_color_b = 0.0;
                                                    
                                                    if(ob_is_defined(label, L"font_color")) {
                                                        PA_ObjectRef color = ob_get_o(label, L"font_color");
                                                        if(color) {
                                                            font_color_r = ob_get_n(color, L"red");
                                                            font_color_g = ob_get_n(color, L"green");
                                                            font_color_b = ob_get_n(color, L"blue");
                                                        }
                                                    }
                                                    
                                                    PdfColor font_color(font_color_r, font_color_g, font_color_b);
                                                    
                                                    if(bUpdateFont)
                                                    {
                                                        PdfFont* pFont;
                                                        
                                                        pFont = document.CreateFont(label_font, false, false, false);
                                                        if(!pFont)
                                                        {
                                                            std::string err = "Failed to create font '";
                                                            err += label_font;
                                                            err += "'";
                                                            
                                                            PODOFO_RAISE_ERROR_INFO( ePdfError_OutOfMemory, err.c_str() );
                                                        }else{
                                                            
                                                            pFont->SetFontSize(label_font_size);
                                                            painter.SetFont(pFont);
                                                            painter.SetColor(font_color);
                                                            
                                                            painter.DrawMultiLineText(
                                                                                      label_left,
                                                                                      0.0,
                                                                                      annot_rect.GetWidth() - label_left,
                                                                                      annot_rect.GetHeight() -  label_top,
                                                                                      PdfString( reinterpret_cast<const pdf_utf8 *>(label_text)));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                        
                                    /*
                                     images
                                     */
                                    
                                    for(PA_long32 i = 0; i < PA_GetCollectionLength(images);++i){
                                        
                                        PA_Variable v = PA_GetCollectionElement(images, i);
                                        if(PA_GetVariableKind(v) == eVK_Object){
                                            PA_ObjectRef image = PA_GetObjectVariable(v);
                                            if(image) {
                                                const char *image_units = NULL;
                                                CUTF8String u8_unit;
                                                if(ob_is_defined(image, L"unit")) {
                                                    if(ob_get_s(image, L"unit", &u8_unit)) {
                                                        if(u8_unit == (const uint8_t *)"inch"){
                                                            image_units = "inch";
                                                        }
                                                    }
                                                }
                                                
                                                if(!image_units)
                                                    image_units = "mm";
                                                
                                                double image_left = ob_get_n(image, L"x");
                                                double image_top = ob_get_n(image, L"y");
                                                double image_width = convert_to_pdf_units(image_units,
                                                                                          ob_get_n(image, L"width"));
                                                double image_height = convert_to_pdf_units(image_units,
                                                                                           ob_get_n(image, L"height"));
                                                
                                                const char *image_file = NULL;
                                                CUTF8String u8_file;
                                                if(ob_is_defined(image, L"file")) {
                                                    if(ob_get_s(image, L"file", &u8_file)) {
                                                        convert_to_platform_path(u8_file);
                                                        image_file = (const char *)u8_file.c_str();
                                                    }
                                                }
                                                
                                                if(image_file) {
                                                    bool image_file_exists = false;
                                                    FILE *fp = ufopen(image_file, "r");
                                                    if(fp) {
                                                        if(fseeko(fp, 0, SEEK_END) != -1){
                                                            image_file_exists = true;
                                                        }
                                                        fclose(fp);
                                                    }
                                                    
                                                    if(image_file_exists) {
                                                    PdfImage image(&document);

#if VERSIONMAC
                                                        image.LoadFromFile(image_file);
#else
                                                        wchar_t    buf[_MAX_PATH];
                                                        if(MultiByteToWideChar(CP_UTF8, 0, (LPCCH)image_file, -1, (LPWSTR)buf, _MAX_PATH))
                                                        {
                                                            image.LoadFromFile((const wchar_t *)buf);
                                                        }
#endif
                                                        double dScaleX = image_width / image.GetWidth();
                                                        double dScaleY = image_height / image.GetHeight();
                                                        
                                                        painter.DrawImage(image_left,
                                                                          annot_rect.GetHeight() - image_top - image_height,
                                                                          &image, dScaleX, dScaleY );
                                                    }
                                                }
                                            }
                                        }
                                    }
                                        pSignField->SetAppearanceStream( &sigXObject );
                                    }
                                    catch( PdfError & e )
                                    {
                                        if( painter.GetPage() )
                                        {
                                            try
                                            {
                                                painter.FinishPage();
                                            }
                                            catch( ... )
                                            {
                                            }
                                        }
                                    }
                                    
                                    painter.FinishPage();
                                }
                            }
                            
                            // use large-enough buffer to hold the signature with the certificate
                            signer.SetSignatureSize( min_signature_size );
                            
                            pSignField->SetFieldName( name );
                            pSignField->SetSignatureReason( PdfString( reinterpret_cast<const pdf_utf8 *>( reason ) ) );
                            pSignField->SetSignatureDate( PdfDate() );
                            pSignField->SetSignature( *signer.GetSignatureBeacon() );
                            
                            // The outputfile != NULL means that the write happens to a new file,
                            // which will be truncated first and then the content of the inputfile
                            // will be copied into the document, follwed by the changes.
                            document.WriteUpdate( &signer, outputfile != NULL );
                            
                            if(!signer.HasSignaturePosition()) {
                                PODOFO_RAISE_ERROR_INFO( ePdfError_SignatureError, "Cannot find signature position in the document data" );
                            }
                            
                            // Adjust ByteRange for signature
                            signer.AdjustByteRange();
                            
                            // Read data for signature and count it
                            // We seek at the beginning of the file
                            signer.Seek( 0 );
                            
                            sign_with_signer( signer, cert, pkey );
                            
                            signer.Flush();
                            
                        }
                    }
                    catch( PdfError & e )
                    {
                        std::cerr << "Error: An error " << e.GetError() << " occurred during the sign of the pdf file:" << std::endl;
                        e.PrintErrorMsg();
                        
                        result = e.GetError();
                    }
                    
                    if(pSignField)
                        delete pSignField;
                    
                    if(pTemporaryAnnot)
                        delete pTemporaryAnnot;
                }
                
                if(pkey)
                    EVP_PKEY_free(pkey);
                
                if(bio_pkey)
                    BIO_free(bio_pkey);
                
                if(cert)
                    X509_free(cert);
                
                if(bio_cert)
                    BIO_free(bio_cert);
            }
        }
        
#ifndef PODOFO_HAVE_OPENSSL_1_1
        ERR_free_strings();
#endif
        
        PA_ReturnObject(params, returnValue);
    }
